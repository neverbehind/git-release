#!/bin/bash

function init {
	RELEASE_VERSION=$1
	if [ -z "$RELEASE_VERSION" ]
	then
		echo "Enter Release Version (e.g. 16_07 or 1.0.0):"
		read -r RELEASE_VERSION
	fi

	RELEASE_CANDIDATE=$2
	if [ -z "$RELEASE_CANDIDATE" ]
	then
		echo "Enter Release Candidate Version (e.g. 1,2,3... or blank for 0, first roll will be 1):"
		read -r RELEASE_CANDIDATE
	fi

	if [ -z "$RELEASE_CANDIDATE" ]
		then
		RELEASE_CANDIDATE="0"
	fi

	git config --local --replace-all releases.version "$RELEASE_VERSION"
	git config --local --replace-all releases.candidate $RELEASE_CANDIDATE

	RELEASE="release-v$RELEASE_VERSION"
	git config --local --replace-all releases.current $RELEASE

	clearbranches

	status
}

# -- display a list of release branches and allows switching between releases and int the correct values
# -- pass true to automatically search for the most recent release candidate for a given release
function checkout {
	LATEST=$1
	fetchall

	if [ -z "$LATEST" ]
	then
		echo "Looking for Release Branches..."
		AVAIL_RELEASES=$(git branch -r | grep origin/release-v)
	else
		echo "Looking for Release Branches Matching $(current)"
		echo "git branch -r | grep origin/$(current)"
		AVAIL_RELEASES=$(git branch -r | grep origin/$(current))
	fi

	if [ -z "$AVAIL_RELEASES" ]
	then
		if [ -z "$LATEST" ]
		then
			echo "No Old Release branches found"
		else
			echo "No releases matching $(current) found"
		fi
		return 1
	fi

	OPTION=0
	OPTIONLIST=()
	echo "Release Branches Found:"
	LATEST_REVISION=0
	REVISION=0
	for AVAIL_RELEASE in $AVAIL_RELEASES
	do
		OPTIONLIST[OPTION]=$AVAIL_RELEASE

		if [ ! -z "$LATEST" ]
		then
			REVISION=${AVAIL_RELEASE#*rc}
			if [ "$REVISION" -gt "$LATEST_REVISION" ]
			then
				LATEST_REVISION=$REVISION
				CHOICE=$OPTION
			fi
		else
			echo "$OPTION $AVAIL_RELEASE"
		fi

		OPTION=$((OPTION+1))
	done

	if [ -z "$LATEST" ]
	then
		echo "Select Branch to Add: (X = cancel)"
		read -r CHOICE
		if [ "$CHOICE" = "X" ] || [ "$CHOICE" = "x" ] || [ -z "$CHOICE" ]
			then exit;
		fi
	else
		# only switch if we aren't already on this release
		if [ "$LATEST_REVISION" = "$(candidate)" ]
		then
			echo "Already on latest release"
			return 0
		fi
		echo "Updating to Latest Release Candidate ${OPTIONLIST[$CHOICE]}"
	fi

	CHOSEN_RELEASE=${OPTIONLIST[$CHOICE]}
	RELEASE_BRANCH=${CHOSEN_RELEASE##*/}
	RELEASE_ONLY=${RELEASE_BRANCH%-*}
	RELEASE_VERSION=${RELEASE_ONLY#*-v}
	RELEASE_CANDIDATE=${RELEASE_BRANCH#*rc}

	echo "Initializing Version: $RELEASE_VERSION rc: $RELEASE_CANDIDATE..."

	init "$RELEASE_VERSION" "$RELEASE_CANDIDATE"

	git checkout "$RELEASE_BRANCH"
	readinreleasefile
	return 0
}

# - creates a new release candidate by branching from the main branch and merging in the added features
function roll {
	# Name of new release branch to be created
	RELEASE_BRANCH=$(nextreleasebranch)

	fetchall

	echo "Creating $RELEASE_BRANCH..."

	git checkout -b "$RELEASE_BRANCH" "$(mainbranch)"

	migratereleases

	writereleasefile

	git add "releases/$(current)"

	echo "$RELEASE_BRANCH" > "version"

	git add "version"

	git commit -m "Adding Release Branch Definition file"

  afterversioncommit

	mergebranches

	findconflicts

	if $FOUND_CONFLICTS
	then
		echo "Not pushing to origin"
		return 1
	else
		echo "Pushing to origin"
		echo "git push origin $RELEASE_BRANCH"
		git push origin "$RELEASE_BRANCH"
		return 0
	fi
}

# - creates a new release candidate by branching from the last RC and merging in the added features
function next {
	# Name of new release branch to be created
	RELEASE_BRANCH=$(releasebranch)
	NEXT_RELEASE_BRANCH=$(nextreleasebranch)

	echo "Creating $RELEASE_BRANCH..."

	git checkout -b "$NEXT_RELEASE_BRANCH" "$RELEASE_BRANCH"

	writereleasefile

	git add "releases/$(current)"

	echo "$NEXT_RELEASE_BRANCH" > "version"

	git add "version"

	git commit -m "Appending Release Branch Definition file"

  afterversioncommit

	mergebranches

	findconflicts

	if $FOUND_CONFLICTS
	then
		echo "Not pushing to origin"
		return 1
	else
		echo "Pushing to origin"
		echo "git push origin $NEXT_RELEASE_BRANCH"
		git push origin "$NEXT_RELEASE_BRANCH"
		return 0
	fi
}

# - like roll, only doesn't create a new branch - merges features into current RC.
function append {
	# Name of new release branch to be created
	RELEASE_BRANCH=$(releasebranch)

	echo "Creating $RELEASE_BRANCH..."

	git checkout -b "$RELEASE_BRANCH" "$(mainbranch)"

	git checkout "$RELEASE_BRANCH"

	writereleasefile

	git add "releases/$(current)"

	echo "$RELEASE_BRANCH" > "version"

	git add "version"

	git commit -m "Appending Release Branch Definition file"

  afterversioncommit

	mergebranches

	findconflicts

	if $FOUND_CONFLICTS
	then
		echo "Not pushing to origin"
		return 1
	else
		echo "Pushing to origin"
		echo "git push origin $RELEASE_BRANCH"
		git push origin "$RELEASE_BRANCH"
		return 0
	fi
}

# -- Grab All Dev Branches and Add them to a new release
function duplicate {
	RELEASE_BRANCHES=$(releasebranches)
	init
	for BRANCH in $RELEASE_BRANCHES
	do
		add "$BRANCH"
	done
	status
}

# -- merge the added feature branches into the currently checked out branch
function mergebranches {
	fetchall
	# Updating main from any updates
	git merge --no-ff --no-edit "origin/$(mainbranch)"

	for BRANCH in $(branches)
	do
		echo "MERGING: $BRANCH ++++++++++++++++++++++++"
	    git merge --no-ff --no-edit "$BRANCH"
	done
}

# -- check the current branch for conflicts
# return 0, true if found
# return 1, false if not found
function findconflicts {
	echo "Looking for conflicts with merge."
	CONFLICTS=$(git diff --name-only --diff-filter=U)
	if [ "$CONFLICTS" = "" ]
	then
		echo "No Conflicts Found"
		FOUND_CONFLICTS=false
		return 1
	else
		echo ""
		echo "WARNING!! The following files contain conflicts:"
		echo "========================================="
		for FILENAME in $CONFLICTS
		do
			echo "$FILENAME"
		done
		echo ""
		echo "You should run:"
		echo "git difftool"
		echo ""
		echo "After you resolve conflicts, remember to add the file and commit the release candidate"
		echo "git commit -a -m \"resolved conflicts\""
		echo "once completed, push it to origin"
		CURRENT_BRANCH=$(git symbolic-ref --short HEAD)
		echo "git push origin $CURRENT_BRANCH"
		echo ""
		echo "NOTE: Once resolved, they should not cause a problem for 'next' or 'append' release builds, but if you 'roll' a new release you will have the issue again. If this happens constantly, it's recommended that you find a way to merge the two interdependent branches and add THAT to the release instead."
		FOUND_CONFLICTS=true
		return 0
	fi
}

# -- merge the current release branch to the staging branch
function stage {
	RELEASE_BRANCH=$(releasebranch)
	STAGE_BRANCH=$(stagebranch)
	fetchall

	NOOUTPUT=$(git checkout "$STAGE_BRANCH" && git pull origin "$STAGE_BRANCH")
	git merge --no-ff --no-edit "$RELEASE_BRANCH"
	git push origin "$STAGE_BRANCH"

	STAGE_DEPLOY_URL=$(stagedeployurl)
	if [ ! -z "$STAGE_DEPLOY_URL" ]
	then
		echo "Do you want to deploy the '$(stagebranch)' branch to the staging branch location? (y/n)"
		read -r DEPLOY_IT

		if [ "$DEPLOY_IT" = "Y" ] || [ "$DEPLOY_IT" = "y" ]
		then
			echo "Sending request to ($STAGE_DEPLOY_URL)"
			curl "$STAGE_DEPLOY_URL"
		fi
	fi
}

# -- merge the current release branch to the qa branch
function qa {
	RELEASE_BRANCH=$(releasebranch)
	QA_BRANCH=$(qabranch)
	fetchall
	NOOUTPUT=$(git checkout $QA_BRANCH && git pull origin $QA_BRANCH)
	git merge --no-ff --no-edit "$RELEASE_BRANCH"
	git push origin "$QA_BRANCH"

	QA_DEPLOY_URL=$(qadeployurl)
	if [ ! -z "$QA_DEPLOY_URL" ]
	then
		echo "Do you want to deploy the '$(qabranch)' branch to the staging branch location? (y/n)"
		read -r DEPLOY_IT

		if [ "$DEPLOY_IT" = "Y" ] || [ "$DEPLOY_IT" = "y" ]
		then
			echo "Sending request to ($QA_DEPLOY_URL)"
			curl "$QA_DEPLOY_URL"
		fi
	fi
}

# -- merge the current release candidate into the main branch
function deploy {
	DEPLOY_ENV=$1
	RELEASE_BRANCH=$(releasebranch)

	fetchall

	if [ -z "$DEPLOY_ENV" ]
		then
		echo "Enter Deploy Environment (dev/stage/qa/prod)"
		read -r DEPLOY_ENV
	fi
	if [ "$DEPLOY_ENV" = "prod" ]
		then
		TRUNK_BRANCH=$(mainbranch)
	fi
	if [ "$DEPLOY_ENV" = "stage" ]
		then
		TRUNK_BRANCH=$(stagebranch)
	fi
	if [ "$DEPLOY_ENV" = "qa" ]
		then
		TRUNK_BRANCH=$(qabranch)
	fi
	if [ "$DEPLOY_ENV" = "dev" ]
		then
		TRUNK_BRANCH=$(devbranch)
	fi

	git checkout "$TRUNK_BRANCH"

	if [ "$DEPLOY_ENV" = "prod" ]
		then
		git pull origin "$TRUNK_BRANCH"
	else
		git reset --hard "$(mainbranch)"
	fi

	git merge --no-ff --no-edit "$RELEASE_BRANCH"
	git push origin "$TRUNK_BRANCH" -f

	if [ "$DEPLOY_ENV" = "prod" ]
		then
		tag
	fi
}

# -- merge the current release candidate into arbitrary branch
function merge {
	MERGE_TO_BRANCH=$1
	RELEASE_BRANCH=$(releasebranch)
	fetchall
	git checkout "$MERGE_TO_BRANCH"
	git pull origin "$MERGE_TO_BRANCH"
	git merge --no-ff --no-edit "$RELEASE_BRANCH"
	git push origin "$MERGE_TO_BRANCH"

	if [ "$MERGE_TO_BRANCH" = "$(mainbranch)" ]
		then
		echo "It's customary to Tag when merging to $(mainbranch), shall we tag with release? (y/n)"
		read -r PUSH
		if [ "$PUSH" = "y" ] || [ "$PUSH" = "Y" ]
			then
			tag
		fi
	fi
}

# -- tags the main branch with the latest version
function tag {
	RELEASE_TAG="v$(version)"
	git tag "$RELEASE_TAG"
	git push --tags
}

# -- List the feature branches currently merged into the development branch
function devbranches {
	DEV_BRANCH=$(devbranch)
	MAIN_BRANCH=$(mainbranch)
	if [ -z "$DEV_BRANCH" ]
		then
			echo "There is no development branch configured (in git config --local releases.devbranch)..."
			echo "Enter your development branch name:"
			read -r DEV_BRANCH
			git config --local --replace-all releases.devbranch "$DEV_BRANCH"
	fi
	fetchall
	NOOUTPUT=$(git checkout -b "$MAIN_BRANCH" "origin/$MAIN_BRANCH" && git pull origin "$MAIN_BRANCH")
	NOOUTPUT=$(git checkout "$DEV_BRANCH" && git pull origin "$DEV_BRANCH")
	comm -12 <(git branch -r --no-merged "$MAIN_BRANCH") <(git branch -r --merged "$DEV_BRANCH") | grep -v "$DEV_BRANCH" | grep -v release
}

# -- configure the url to call after merging a feature into develop branch
function setdevdeployurl {
	DEPLOY_URL=$1
	if [ -z "$DEPLOY_URL" ]
	then
		echo "Enter the Rest URL to call to deploy the '$(devbranch)' branch. Blank to disable branch deployment."
		read -r DEPLOY_URL
	fi

	if [ -z "$DEPLOY_URL" ]
	then
		git config --local --unset-all releases.devdeployurl
	else
		git config --local --replace-all releases.devdeployurl "$DEPLOY_URL"
	fi
}


# -- list the feature branches currently merged into the staging branch
function stagebranches {
	STAGE_BRANCH=$(stagebranch)
	if [ -z "$STAGE_BRANCH" ]
		then
			echo "There is no staging branch configured (in git config --local releases.stagebranch)..."
			echo "Enter your staging branch name:"
			read -r STAGE_BRANCH
			git config --local --replace-all releases.stagebranch "$STAGE_BRANCH"
	fi
	fetchall
	NOOUTPUT=$(git checkout "$STAGE_BRANCH" && git pull origin "$STAGE_BRANCH")
	comm -12 <(git branch -r --no-merged "$(mainbranch)") <(git branch -r --merged "$STAGE_BRANCH") | grep -v "$STAGE_BRANCH" | grep -v release
}

# -- list the feature branches currently merged into the staging branch
function qabranches {
	QA_BRANCH=$(qabranch)
	if [ -z "$QA_BRANCH" ]
		then
			echo "There is no QA branch configured (in git config --local releases.qabranch)..."
			echo "Enter your QA branch name:"
			read -r QA_BRANCH
			git config --local --replace-all releases.qabranch $QA_BRANCH
	fi
	fetchall
	NOOUTPUT=$(git checkout "$QA_BRANCH" && git pull origin "$QA_BRANCH")
	comm -12 <(git branch -r --no-merged "$(mainbranch)") <(git branch -r --merged "$QA_BRANCH") | grep -v "$QA_BRANCH" | grep -v release
}

# -- configure the url to call after merging a feature into staging/qa branch
function setstagedeployurl {
	DEPLOY_URL=$1
	if [ -z "$DEPLOY_URL" ]
	then
		echo "Enter the Rest URL to call to deploy the '$(stagebranch)' branch. Blank to disable branch deployment."
		read -r DEPLOY_URL
	fi

	if [ -z "$DEPLOY_URL" ]
	then
		git config --local --unset-all releases.stagedeployurl
	else
		git config --local --replace-all releases.stagedeployurl "$DEPLOY_URL"
	fi
}

# -- configure the url to call after merging a feature into staging/qa branch
function setqadeployurl {
	DEPLOY_URL=$1
	if [ -z "$DEPLOY_URL" ]
	then
		echo "Enter the Rest URL to call to deploy the '$(qabranch)' branch. Blank to disable branch deployment."
		read -r DEPLOY_URL
	fi

	if [ -z "$DEPLOY_URL" ]
	then
		git config --local --unset-all releases.qadeployurl
	else
		git config --local --replace-all releases.qadeployurl "$DEPLOY_URL"
	fi
}

# -- merge a feature into the dev branch and offer to push to origin
function devfeature {
	DEV_BRANCH=$(devbranch)
	#git checkout $DEV_BRANCH
	#git pull origin $DEV_BRANCH
	fetchall
	NOOUTPUT=$(git checkout "$DEV_BRANCH" && git pull origin "$DEV_BRANCH")

	# feature might have been found by calling function
	if [ -z "$FEATURE_CHOSEN" ]
	then
		findfeature $1
	fi
	echo "Merging $FEATURE_CHOSEN into $DEV_BRANCH"
	git merge --no-ff --no-edit "$FEATURE_CHOSEN"

	findconflicts

	if $FOUND_CONFLICTS
	then
		echo "exiting"
		exit
	fi

	echo "Push '$DEV_BRANCH' up to Origin? (y/n)"
	read -r PUSH
	if [ "$PUSH" = "y" ] || [ "$PUSH" = "Y" ]
		then
		git push origin "$DEV_BRANCH"

		DEV_DEPLOY_URL=$(devdeployurl)
		if [ ! -z "$DEV_DEPLOY_URL" ]
		then
			echo "Do you want to deploy the '$(devbranch)' branch to the dev branch location? (y/n)"
			read -r DEPLOY_IT

			if [ "$DEPLOY_IT" = "Y" ] || [ "$DEPLOY_IT" = "y" ]
			then
				echo "Sending request to ($DEV_DEPLOY_URL)"
				curl "$DEV_DEPLOY_URL"
			fi
		fi

	else
		echo "skipping"
	fi
}


# - loop through all local branches and pull them if they are behind
function updatelocal {
	CURRENT_BRANCH=`git symbolic-ref --short HEAD`

	LOCAL_MODS=$(git status -sb | grep "M " | cut -c4-)
	STASHED=false

	if [ "$LOCAL_MODS" != "" ]
	then
		echo "You have the following locally modified files:"
		for MODDED in $LOCAL_MODS
		do
			echo "$MODDED"
		done
		echo ""
		echo "Do you want to stash them before doing an update?"
		echo "y - to stash and restore after completed"
		echo "n - to pull on top of your local changes - may cause conflicts"
		echo "x to exit now"
		read -r STASH_IT

		if [ "$STASH_IT" == "Y" ] ||  [ "$STASH_IT" == "y" ]
		then
			echo "Stashing local changes"
			git stash save
			STASHED=true

		elif [ "$STASH_IT" == "N" ] ||  [ "$STASH_IT" == "n" ]
		then
			echo "Not stashing local changes"
		else
			echo "Cancelling"
			exit
		fi
	fi

	fetchall
	ALL_LOCAL=$(git branch)
	ALL_LOCAL=${ALL_LOCAL//\*}
	for BRANCH in $ALL_LOCAL
	do
		echo "Examining Local Branch: $BRANCH"
		NOOUTPUT=$(git checkout "$BRANCH")
		echo "Checking Status"
		GIT_BEHIND=$(git status -sb | grep behind)
		GIT_AHEAD=$(git status -sb | grep ahead)
		if [ ! "$GIT_BEHIND" = "" ]
		then
			if [ "$GIT_AHEAD" = "" ]
			then
				echo "Pulling Branch $BRANCH"
				git pull
			else
				echo "Local Branch $BRANCH is Ahead of origin."
				echo "Not Pulling"
				echo "Press Enter to Continue"
				read -r NOTHING
			fi
		else
			echo "Nothing to Update"
		fi
	done

	NOW_ON=$(git symbolic-ref --short HEAD)
	if [ "$NOW_ON" != "$CURRENT_BRANCH" ]
	then
		echo "Putting you back on your original branch"
		git checkout "$CURRENT_BRANCH"
	fi

	if $STASHED
	then
		git stash pop
	fi
}

# - make a new feature branch, pushing to origin - case insensitive check for duplicates
function newfeature {
	echo "What type of feature are you working on making?"
	echo "0 - enter whole name"
	echo "1 - feature/"
	echo "2 - bugfix/"
	echo "3 - hotfix/"
	read -r THE_KIND
	if [ "$THE_KIND" = "0" ]
	then
		PREFIX=""
	elif [ "$THE_KIND" = "1" ]
	then
		PREFIX="feature/"
	elif [ "$THE_KIND" = "2" ]
	then
		PREFIX="bugfix/"
	elif [ "$THE_KIND" = "3" ]
	then
		PREFIX="hotfix/"
	else exit
	fi

	echo "Enter a descriptive name for your feature."
	echo "(e.g. 'ISSUE-33_IncreaseTitleFont')"
	read -r TITLE
	if [ -z "$TITLE" ]
	then
		exit
	fi

	NEW_FEATURE="$PREFIX$TITLE"

	echo "'$NEW_FEATURE'"

	echo "Making Sure it Doesn't Exist"
	fetchall
	BRANCHES=$(git branch -a | grep -i $NEW_FEATURE)
	BRANCHES=${BRANCHES//\*}

	for BRANCH in $BRANCHES
	do
		trimfeaturename "$BRANCH"
		shopt -s nocasematch
		if [[ "$TRIMMED_FEATURE_NAME" = "$NEW_FEATURE" ]]
		then
			echo "$NEW_FEATURE Already Exists as $BRANCH"
			echo "Try Running:"
			echo "git checkout $TRIMMED_FEATURE_NAME"
			exit
		fi
		shopt -u nocasematch

	done

	echo "Create the above branch? (y/n)"

	read -r CREATE_IT
	if [ "$CREATE_IT" = "Y" ] || [ "$CREATE_IT" = "y" ]
	then
		echo "git fetch --all"
		# already ran it to find the feature name
		# git fetch --all
		echo "git checkout -b $PREFIX$TITLE origin/$(mainbranch)"
		git checkout -b "$PREFIX$TITLE" "origin/$(mainbranch)"
		echo "git push -u origin $PREFIX$TITLE"
		git push -u origin "$PREFIX$TITLE"
	fi
}

# -- push the current branch to origin
## offer to merge to develop if not done already
## offer to roll new rc if it's been added to release
## offer to stage rc
function pushfeature {

	DEV_BRANCH=$(devbranch)

	NEXT_REL_CANDIDATE=$(candidate)

	# do a lookup of local feature branches
	CURRENT_BRANCH=$(git symbolic-ref --short HEAD)

	echo "Current Branch is '$CURRENT_BRANCH'"

	if [ "$CURRENT_BRANCH" = "$(stagebranch)" ] || [ "$CURRENT_BRANCH" = "$(devbranch)" ] || [ "$CURRENT_BRANCH" = "$(mainbranch)" ] || [ "$CURRENT_BRANCH" = "$(qabranch)" ]
	then
		echo "Be Sure to Checkout a Feature Branch First"
		echo ""
		echo "Try Running:"
		echo "git release checkoutfeature"
		exit
	fi


	echo "Is this the branch you are trying to push? (y/n)"
	read -r IS_THIS_IT

	if [ ! "$IS_THIS_IT" = "Y" ] && [ ! "$IS_THIS_IT" = "y" ]
	then
		echo "Be Sure to Checkout the Branch That You Are Attempting to Push."
		echo "Try Running:"
		echo "git release checkoutfeature"
		exit
	fi

	fetchall

	FEATURE_CHOSEN=$CURRENT_BRANCH

	PF_ON_ORIGIN=$(git status -sb | grep origin)

	PF_AHEAD=$(git status -sb | grep ahead)

	PF_BEHIND=$(git status -sb | grep behind)

	if [ ! "$PF_BEHIND" = "" ]
	then
		echo "Your Local Branch is Behind origin."
		echo "You Should Merge the Changes From origin Prior to Pushing to origin"
		echo "e.g."
		echo "git pull"
		exit
	fi

	if [ "$PF_AHEAD" = "" ] && [ ! "$PF_ON_ORIGIN" = "" ]
	then
		echo "Branch '$FEATURE_CHOSEN' is already up to date on origin."
		echo "Not Pushing"
		echo ""
	elif [ "$PF_ON_ORIGIN" = "" ]
	then
		echo "Branch '$FEATURE_CHOSEN' Was Not Found on origin. Doing First Time Push."
		git push -u origin "$FEATURE_CHOSEN"
	else
		echo "Please review and confirm before pushing the following changes:"
		echo "$PF_AHEAD"
		echo "Continue pushing '$FEATURE_CHOSEN' to origin? (y/n)"
		read -r PUSH_AHEAD
		if [ "$PUSH_AHEAD" = "Y" ] || [ "$PUSH_AHEAD" = "y" ]
		then
			echo "Pushing '$FEATURE_CHOSEN' to origin"
			git push origin "$FEATURE_CHOSEN"
		else
			exit
		fi
	fi

	# see if it's been merged into develop already
	echo "Checking to see if the branch has been merged to $DEV_BRANCH"

	echo "git branch -r --no-merged $DEV_BRANCH | grep $FEATURE_CHOSEN"

	PF_BRANCHES=$(git branch -r --no-merged "$DEV_BRANCH" | grep "$FEATURE_CHOSEN")

	MERGE_TO_DEV=false
	for PF_BRANCH in $PF_BRANCHES
	do
		if [ "$PF_BRANCH" = "$FEATURE_CHOSEN" ]
		then
			MERGE_TO_DEV=true
		fi
	done

	if $MERGE_TO_DEV
	then
		echo "Merging into '$DEV_BRANCH'"
		devfeature "$FEATURE_CHOSEN"
	else
		echo "It's been merged into develop before"
		# second value is how many revisions feature chosen is ahead of dev branch
		AHEAD_REV=$(git rev-list --left-right --count $DEV_BRANCH..$FEATURE_CHOSEN | cut -f2)
		echo "Ahead by $AHEAD_REV"

		if [ ! "$AHEAD_REV" = "0" ]
		then
			echo "It is ahead by $AHEAD_REV revisions"
			echo "Merging changes"
			devfeature "$FEATURE_CHOSEN"
		else
			echo "Feature '$FEATURE_CHOSEN' already up to date on '$DEV_BRANCH' - skipping merge"
		fi
		echo ""
	fi


	echo "Do you want to try to push this feature to the latest release candidate for '$(current)'? (y/n)"
	read -r IS_IT

	if [ "$IS_IT" = "Y" ] || [ "$IS_IT" = "y" ]
	then
		echo "Searching For Latest Release Info"
		checkout true
	else
		git checkout "$CURRENT_BRANCH"
		echo "Done"
		exit
	fi

	ROLL_NEW_RELEASE=false
	PUSH_BRANCHES=$(branches)
	for P_BRANCH in $PUSH_BRANCHES
	do
		trimfeaturename "$P_BRANCH"
		if [ "$TRIMMED_FEATURE_NAME" = "$FEATURE_CHOSEN" ]
		then
			ROLL_NEW_RELEASE=true
		fi
	done

	if $ROLL_NEW_RELEASE
	then
		echo "'$FEATURE_CHOSEN' is part of '$(current)'. Do you want to roll a new release candidate as well?"
		echo ""
		echo "Choose one of the following options or X to exit"
		echo "0 skip this step"
		echo "1 roll - makes a new branch from the main branch and merges in all features - required for first release candidate and when features are removed."
		if [ "$(candidate)" != "0" ]
		then
			echo "2 next - branches from '$(releasebranch)' to create '$(current)rc$((NEXT_REL_CANDIDATE+1))'; easier to diff changes between release candidates"
			echo "3 append - merges on top of current release candidate '$(releasebranch)' - not recommended if you add a new feature. See 'help' for details."
		fi
		read -r ROLL_IT
		if [ "$ROLL_IT" = "1" ]
		then
			echo "Rolling new release from the main branch"
			roll
			ROLL_SUCCESSFUL=$?
			echo "New release candidate is: $(releasebranch)"
		elif [ "$ROLL_IT" = "2" ] && [ "$(candidate)" != "0" ]
		then
			echo "Rolling new release from current"
			next
			ROLL_SUCCESSFUL=$?
			echo "New release candidate is: $(releasebranch)"
		elif [ "$ROLL_IT" = "3" ] && [ "$(candidate)" != "0" ]
		then
			echo "Appending to current release"
			append
			ROLL_SUCCESSFUL=$?
		elif [ "$ROLL_IT" = "0" ]
		then
			echo "skipping making a new release candidate"
		else
			git checkout "$CURRENT_BRANCH"
			exit
		fi

		echo ""

		if [ "$ROLL_SUCCESSFUL" = "0" ]
		then
			echo "Do you want to deploy this release candidate into the '$(stagebranch)' branch? (y/n)"
			read -r STAGE_IT

			if [ "$STAGE_IT" = "Y" ] || [ "$STAGE_IT" = 'y' ]
			then
				echo "Putting release candidate into '$(stagebranch)'.."
				stage
			else
				git checkout "$CURRENT_BRANCH"
				exit
			fi
		fi
	else
		echo "'$FEATURE_CHOSEN' is not part of the current release."
		echo "To add it to the release, run:"
		echo "git release add $FEATURE_CHOSEN"
	fi
	git checkout "$CURRENT_BRANCH"
}

# -- List which branches are part of the current release that are not yet in the main branch
function releasebranches {

	CURRENT_RELEASE_BRANCH=$(releasebranch)
	fetchall
	NOOUTPUT=$(git checkout "$CURRENT_RELEASE_BRANCH" && git pull origin "$CURRENT_RELEASE_BRANCH")
	comm -12 <(git branch -r --no-merged "$(mainbranch)") <(git branch -r --merged "$CURRENT_RELEASE_BRANCH") | grep -v "$CURRENT_RELEASE_BRANCH" | grep -v release
}

## Lab -- Expiremental Functions

# -- Grab All Dev Branches and Add them to a new release
function createdevrelease {
	echo "createrelease"
	echo "Enter Current Release Number:"
	read -r RELEASE_NUMBER
	init "$RELEASE_NUMBER-devrefresh" 0
	DEV_BRANCHES=$(devbranches)
	for BRANCH in $DEV_BRANCHES
	do
		add "$BRANCH"
	done
	roll
}

# -- Experimental Dev Branch Refresh Mechanism
# -- Uses hard resets to make the dev branch more portable, tagging could also be employed
function movedevbranch {
	PREV_DEVBRANCH="$(devbranch)-prev"
	git checkout -b $PREV_DEVBRANCH || git checkout $PREV_DEVBRANCH
	git reset --hard "$(devbranch)"
	git checkout "$(devbranch)"
	git reset --hard "$(releasebranch)"
}

function cleanup {
	echo "Did we want to clean up the release branches?"
	read -r CHOICE
	if [ "$CHOICE" = "Y" ] || [ "$CHOICE" = "y" ]
		then
		cleanrelease "$@"
	fi

	echo "Did we want to purge the local merged branches?"
	read -r CHOICE
	if [ "$CHOICE" = "Y" ] || [ "$CHOICE" = "y" ]
		then
		cleanupmergedlocalbranches
	fi

	echo "Did we want to purge the remote merged branches?"
	read -r CHOICE
	if [ "$CHOICE" = "Y" ] || [ "$CHOICE" = "y" ]
		then
		cleanupmergedremotebranches
	fi

}

# -- lists old releases and allows you to remove them from origin and local
function cleanrelease {
	git checkout "$(mainbranch)"
	git pull origin "$(mainbranch)"

	CURRENT_RELEASE=$1
	if [ -z "$CURRENT_RELEASE" ]
		then CURRENT_RELEASE=$(current)
	fi

	echo "Looking for Old Release Branches for $CURRENT_RELEASE..."
	OLD_RELEASES=$(git branch -r | grep $CURRENT_RELEASE | grep -v "$(releasebranch)")

	if [ -z "$OLD_RELEASES" ]
	then
		echo "No Old Release branches found"
	else
		for OLD_RELEASE_BRANCH in $OLD_RELEASES
		do
			RELEASE_ONLY=${OLD_RELEASE_BRANCH##*/}
		    echo "Remove: $RELEASE_ONLY (y/n)"
		    read -r CHOICE
		    if [ "$CHOICE" = "Y" ] || [ "$CHOICE" = "y" ]
			then
				git push origin --delete "$RELEASE_ONLY"
				git branch -D "$RELEASE_ONLY"
			fi
		done
	fi

}

# -- allows you to remove local branches that have been merged into the main branch
function cleanupmergedlocalbranches {
	CHOICE="n"
	git config --global pager.branch false
	git checkout "$(mainbranch)"
	git pull origin "$(mainbranch)"
	GREP_CMD="git branch --merged | grep -v release | grep -v $(mainbranch)"
	MERGED_BRANCHES=$(git branch --merged | grep -v "$(mainbranch)" | grep -v "$(qabranch)" | grep -v "$(stagebranch)" | grep -v "$(devbranch)")
	echo "$MERGED_BRANCHES"
	for RMM_BRANCH in $MERGED_BRANCHES
	do
		echo "Pulling Branch: $RMM_BRANCH"
		if [ "$CHOICE" = "auto" ]
			then
			echo "Removing $RMM_BRANCH"
			git branch -d "$RMM_BRANCH"
		else
			echo "$RMM_BRANCH shows to be merged to the main branch, remove? (y/n)"
			read -r CHOICE
			if [ "$CHOICE" = "Y" ] || [ "$CHOICE" = "y" ] || [ "$CHOICE" = "auto" ]
			then
				git branch -d "$RMM_BRANCH"
			fi
		fi
	done
}

# -- allows you to remove remote branches that have been merged into the main branch
function cleanupmergedremotebranches {
	CHOICE="n"
	echo "IMPORTANT: You should have the most current release branch checked out"
	echo "IMPORTANT: You should have have already run 'git release deploy' to have the main branch merged in"
	echo "Are these things handled? (y/n)"
	read -r CONFIRMATION
	if [ "$CONFIRMATION" = "Y" ] || [ "$CONFIRMATION" = "y" ]
		then echo "Thanks for Confirming"
		else exit
	fi
	git config --global pager.branch false
	git checkout "$(mainbranch)"
	git pull origin "$(mainbranch)"
	MERGED_BRANCHES=$(git branch -a --merged | grep remotes | grep -v "$(mainbranch)")
	for RMM_BRANCH in $MERGED_BRANCHES
	do
		echo "Pulling Branch: $RMM_BRANCH"
		RMM_BRANCH_ONLY=${RMM_BRANCH#*remotes/origin/}
		RELEASE_BRANCHES=$(branches)
		if [[ $RELEASE_BRANCHES == *"$RMM_BRANCH"* ]]
			then
				echo "Found in current release !!! $RMM_BRANCH"
		fi
		if [[ $RELEASE_BRANCHES != *"$RMM_BRANCH"* ]]
			then
			if [ "$CHOICE" = "auto" ]
				then
				git push origin --delete "$RMM_BRANCH_ONLY"
			else
				echo "$RMM_BRANCH_ONLY shows to be merged to the main branch, remove? (y)"
				read -r CHOICE
				if [ "$CHOICE" = "Y" ] || [ "$CHOICE" = "y" ] || [ "$CHOICE" = "auto" ]
					then
					git push origin --delete "$RMM_BRANCH_ONLY"
				fi
			fi
		fi
	done
}

# -- remove all local branches except the main branch
function purgelocalbranches {
	git branch | grep -v "$(mainbranch)" | xargs git branch -d
}

## -- End Lab

function reset {
	git reset --hard
}

# -- push the release branch to origin
function push {
	git push origin "$(releasebranch)"
}

# -- remove the current release from origin and roll back a release candidate number
function dump {
	RELEASE_BRANCH="$(releasebranch)"
	echo "Dumping $RELEASE_BRANCH, correct? (Y/N):"
	read -r DUMP
	if [ "$DUMP" = "Y" ]
	then
		git reset --hard
		git checkout "$(mainbranch)"
		git branch -D "$RELEASE_BRANCH"
		git push origin --delete "$RELEASE_BRANCH"
		RELEASE_CANDIDATE=$(git config --get-all releases.candidate)
		git config --local --replace-all releases.candidate "$((RELEASE_CANDIDATE-1))"
	fi
}

# -- manually edit the release file and then read -r in the settings
function edit {
	nano "releases/$(current)"
	readinreleasefile
}

# -- checkout the current release branch and write a release filex
function writeout {
	git checkout "$(releasebranch)"
	writereleasefile
}

function writereleasefile {
	echo "" > "releases/$(current)"
	for BRANCH in $(branches)
	do
	    echo "$BRANCH" >> "releases/$(current)"

	done
}

function readin {
	readinreleasefile
}

function readinreleasefile {
	clearbranches
	for BRANCH in `cat releases/$(current) $(current)`
	do
	    add "$BRANCH"
	done
	git reset --hard
	status
}

# -- moves the contents from release to releases
function migratereleases {
	mkdir releases
	if [ ! -f "releases/.htaccess" ]
	then
		echo "Order deny,allow" > "releases/.htaccess"
		echo "Deny from all" >> "releases/.htaccess"
		git add "releases/.htaccess"
	fi

	COMMIT=0
	for RELEASE_FILE in `ls release-v*`
	do
		echo "Moving Release File: $RELEASE_FILE to releases folder."
	    mv "$RELEASE_FILE" releases/
	    git add "releases/$RELEASE_FILE"
	    git rm "$RELEASE_FILE"
	    COMMIT=$((COMMIT+1))
	done
	if [ "$COMMIT" -gt "0" ]
	then
		git commit -m "Migrate Releases"
	fi
}

# -- remove all the branches from the release
function clearbranches {
	git config --unset-all releases.branches
}

# -- finds a feature by name - if none provided allows the user to search by name or type
function findfeature {
	FEATURE_QUERY=$1

	if [ -z "$FEATURE_QUERY" ]
	then
		echo "Find a branch by type, or search for it by name: "
		echo "0 Search by name"
		echo "1 List all feature/ branches"
		echo "2 List all bugfix/ branches"
		echo "3 List all hotfix/ branches"
		read -r SEARCH_TYPE

		if [ "$SEARCH_TYPE" = "0" ]
	    then
			echo "Enter part of a Feature Branch name: (we will search for it) "
			read -r FEATURE_QUERY
		elif [ "$SEARCH_TYPE" = "1" ]
		then
			FEATURE_QUERY="feature/"
		elif [ "$SEARCH_TYPE" = "2" ]
		then
			FEATURE_QUERY="bugfix/"
		elif [ "$SEARCH_TYPE" = "3" ]
		then
			FEATURE_QUERY="hotfix/"
		else
			exit;
		fi
	fi

	if [ -z "$FF_LOCAL_ONLY" ] || ! $FF_LOCAL_ONLY
	then
		FF_BRANCHES=$(git branch -a | grep $FEATURE_QUERY)
	else
		FF_BRANCHES=$(git branch | grep $FEATURE_QUERY)
	fi
	# set it back to false - must be set to true by caller to work
	FF_LOCAL_ONLY=false
	# the current branch will have an asterisk at the front

	FF_BRANCHES=${FF_BRANCHES//\*}
	OPTION=0
	OPTIONLIST=()

	if [ "$FF_BRANCHES" = "" ]
	then
		echo "No Branch Found Matching '$FEATURE_QUERY'"
		FEATURE_CHOSEN=""
	else
		echo "Branches Found:"
		for FF_BRANCH in $FF_BRANCHES
		do
			echo "$OPTION $FF_BRANCH"
			OPTIONLIST[OPTION]=$FF_BRANCH
			OPTION=$((OPTION+1))
		done
		echo "Select Branch: (X = cancel)"
		read -r CHOICE
		if [ "$CHOICE" = "X" ] || [ "$CHOICE" = "x" ] || [ -z "$CHOICE" ]
			then exit;
		fi
		FEATURE_CHOSEN=${OPTIONLIST[$CHOICE]}
		echo "Selected: $FEATURE_CHOSEN"
	fi

}

# -- allows the user to checkout a feature branch
function checkoutfeature {
	findfeature $1
	trimfeaturename ${FEATURE_CHOSEN}
	if [ "$FEATURE_CHOSEN" = "$TRIMMED_FEATURE_NAME" ]
	then
		echo "checking out local branch $FEATURE_CHOSEN"
		git checkout $FEATURE_CHOSEN
	else
		CF_BRANCHES=`git branch -a | grep -v remotes`
		BRANCH_FOUND=false

		for BNAME in CF_BRANCHES
		do
			if [ "$BNAME" = "$TRIMMED_FEATURE_NAME" ]
			then
				BRANCH_FOUND=true
			fi
		done

		if [ $BRANCH_FOUND ]
		then
			echo "local branch $TRIMMED_FEATURE_NAME already exists"
			git checkout "$TRIMMED_FEATURE_NAME"
		else
			echo "checking out remote branch $FEATURE_CHOSEN as $TRIMMED_FEATURE_NAME"
			git checkout -b "$TRIMMED_FEATURE_NAME" "$FEATURE_CHOSEN"
		fi
	fi
}

# -- removes remotes/origin/ from beginning of feature name
function trimfeaturename {
	TRIMMED_FEATURE_NAME=$1
	for TRIMIT in remotes origin
	do
		if [ "${TRIMMED_FEATURE_NAME%%/*}" = "$TRIMIT" ]
		then
			TRIMMED_FEATURE_NAME=${TRIMMED_FEATURE_NAME#*/}
		fi
	done
}

# -- initiates feature search and calls add
function feature {
	findfeature $1
	add "${FEATURE_CHOSEN#*/}"
	status
}

# -- util - does the add of the feature to the branch
function add {
	BRANCH_TO_ADD=$1
	CURRENT_RELEASE=$(current)
	if [ -z "$CURRENT_RELEASE" ]
		then
		echo "No Release is Initialized"
		exit 1;
	fi
	git config --add releases.branches "$BRANCH_TO_ADD"
}

# -- lists currently configured branches for the release and lets you remove one
function rm {
	RM_BRANCHES=$(branches)
	OPTION=0
	OPTIONLIST=()
	echo "Branches Found:"
	for BRANCH in $RM_BRANCHES
	do
		echo "$OPTION $BRANCH"
		OPTIONLIST[OPTION]=$BRANCH
		OPTION=$((OPTION+1))
	done
	echo "Select Branch to Remove: (X = cancel)"
	read -r CHOICE
	if [ "$CHOICE" = "X" ] || [ "$CHOICE" = "x" ] || [ -z "$CHOICE" ]
		then exit;
	fi
	RM_BRANCH_CHOSEN=${OPTIONLIST[$CHOICE]}

	remove "$RM_BRANCH_CHOSEN"

}

# -- util - removes the specified branch from the branch config
function remove {
	RM_FEATURE_BRANCH=$1
	RM_BRANCHES=$(branches)
	clearbranches
	for RM_BRANCH in $RM_BRANCHES
	do
		if [ "$RM_FEATURE_BRANCH" != "$RM_BRANCH" ]
			then
			add $RM_BRANCH
		fi
	done
	status
}

# -- util - format the name for the current release branch
function releasebranch {
	echo "$(current)-rc$(candidate)"
}

# -- util - format the name for the next release branch
function nextreleasebranch {
	echo "$(current)-rc$(nextcandidate)"
}

# -- util - increment the release candidate number and return the value
function nextcandidate {
	RELEASE_CANDIDATE=$(git config --get-all releases.candidate)
	git config --local --replace-all releases.candidate "$((RELEASE_CANDIDATE+1))"
	echo "$((RELEASE_CANDIDATE+1))"
}

# -- util - set the next release candidate number
function setcandidate {
	RELEASE_CANDIDATE=$1
	git config --local --replace-all releases.candidate "$RELEASE_CANDIDATE"
	echo "Release Candidate set to: $RELEASE_CANDIDATE"
}

# -- util - get the currently configured release candidate number
function candidate {
	git config --get-all releases.candidate
}

# -- util - get all of the release versions
function version {
	git config --get-all releases.version
}

# -- util - get the current release version
function current {
	# "Used to list the release info"
	git config --get-all releases.current
}

# -- util - list all of the branches to be merged into the current release
function branches {
	git config --get-all releases.branches
}

# -- util - execute after version commit script if exists
function afterversioncommit {
	if [ -e afterversioncommit.sh ]
	then
		bash afterversioncommit.sh
	fi
}

# -- util - get the name of the development branch
function devbranch {
	git config --get-all releases.devbranch
}

# -- util - get the url to call to deploy the develop branch
function devdeployurl {
	git config --get-all releases.devdeployurl
}

function stagebranch {
	# "Used to fetch the stored staging branch"
	git config --get-all releases.stagebranch
}

# -- util - get the url to call to deploy the stage branch
function stagedeployurl {
	git config --get-all releases.stagedeployurl
}

function qabranch {
	# "Used to fetch the stored qa branch"
	git config --get-all releases.qabranch
}

# -- util - get the url to call to deploy the qa branch
function qadeployurl {
	git config --get-all releases.qadeployurl
}

# -- util - get the name of the main branch
function mainbranch {
	MAIN_BRANCH=$(git config --get-all releases.mainbranch)
	if [ -z "$MAIN_BRANCH" ]
		then
		git config --local --replace-all releases.mainbranch "main"
		MAIN_BRANCH=$(git config --get-all releases.mainbranch)
	fi
	echo "$MAIN_BRANCH"
}

# -- util - set the name of the main branch
function setmainbranch {
	MAIN_BRANCH=$1
	git config --local --replace-all releases.mainbranch "$MAIN_BRANCH"
}

# -- util - get the name of the main branch
function stagebranch {
	STAGE_BRANCH=$(git config --get-all releases.stagebranch)
	if [ -z "$STAGE_BRANCH" ]
		then
		git config --local --replace-all releases.stagebranch "staging"
		STAGE_BRANCH=$(git config --get-all releases.stagebranch)
	fi
	echo "$STAGE_BRANCH"
}

# -- util - set the name of the main branch
function setstagebranch {
	STAGE_BRANCH=$1
	git config --local --replace-all releases.stagebranch "$STAGE_BRANCH"
}

# -- util - get the name of the qa branch
function qabranch {
	QA_BRANCH=$(git config --get-all releases.qabranch)
	if [ -z "$QA_BRANCH" ]
		then
		git config --local --replace-all releases.qabranch "qa"
		QA_BRANCH=$(git config --get-all releases.qabranch)
	fi
	echo "$QA_BRANCH"
}

# -- util - set the name of the qa branch
function setqabranch {
	QA_BRANCH=$1
	git config --local --replace-all releases.qabranch "$QA_BRANCH"
}

# -- util - get the name of the main branch
function setdevelopbranch {
	DEVELOP_BRANCH=$1
	git config --local --replace-all releases.devbranch "$DEVELOP_BRANCH"
}

FETCHED_ALL=false
# - used to make sure we only run fetch --all once per request when functions call each other
function fetchall {
	if ! $FETCHED_ALL
	then
		git fetch --all
		FETCHED_ALL=true
	fi
}

function status {
	if [ -z "$(current)" ]
		then
		echo " "
		echo " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = "
		echo "  No Release Found: run 'git release init' to setup release"
		echo " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = "
		echo " "
		exit
	fi

	IN_BRANCH_CMD="git branch --merged $(mainbranch) | grep $(releasebranch)"
	IN_MAIN=$($IN_BRANCH_CMD)
	if [ -z "$IN_MAIN" ]
		then echo "Status: Pending (Not merged into $(mainbranch))"
		else echo "Status: Deployed (Merged into Main)"
	fi

	echo "Main Branch: $(mainbranch)"
	echo "Staging Branch: $(stagebranch)"
	echo "QA Branch: $(qabranch)"
	echo "Development Branch: $(devbranch)"

	echo "Current Release: $(current)"
	echo "Release Branch:  $(releasebranch)"
	echo "Branches in this Release:"
	for BRANCH in $(branches)
	do
		echo " ++ $BRANCH"
	done

}

function deploystatus {
	status

	echo "Branches in release not in $(mainbranch):"
	for UNMERGED_BRANCH in $(releasebranches)
	do
		if [ "$UNMERGED_BRANCH" == "Fetching" ]
			then continue
		fi
		COMMIT=$(git rev-parse "$UNMERGED_BRANCH")
		echo "$UNMERGED_BRANCH @ $COMMIT"
	done
}

function help {
	echo " "
	echo " * * * HELP * * * * * * * * "
	echo " "
	echo " There are 2 ways to use 'git release':"
	echo " "
	echo "  1. Automatic :: 'git release init' stores the release versioning information in 'git config'"
	echo "        - use 'git release init [version] [candidate]' to configure release versions"
	echo "        - use 'git release devfeature [feature name]' to merge a feature into the development branch and push it to origin"
	echo "             + if you have a devdeployurl set up, it offers to call it to push to your dev integration environment"
	echo "        - use 'git release add [full remote branch path]' to add feature branches into the list to release"
	echo "        - use 'git release feature [branch search string]' to search for and add feature branches into the list to release"
	echo "        - use 'git release remove [full remote branch path]' to remove feature branches from the list"
	echo "        - use 'git release status' to see what version you are on and the branches added"
	echo "        - use 'git release roll' to roll out a new release candidate branch, which:"
	echo "             + Creates a new branch based on release versioning, incrementing the RC"
	echo "             + Commits the Branch list to the new branch"
	echo "             + Merges in each of the added feature branches"
	echo "        - use 'git release append' similar to roll, but doesn't create a new release branch, simple remerges all branches into the current RC"
	echo "        - use 'git release next' similar to roll, but uses current release branch as the base branch, instead of the main branch"
	echo "        - use 'git release stage' to merge the release candidate into your staging branch"
	echo "             + if you have a stagedeployurl set up, it offers to call it to push to your qa/staging environment"
	echo "        - use 'git release deploy' checkout the main branch, and merge in release branch and tag commit with release tag."
	echo "        - use 'git release dump' deletes release branch and rolls back the candidate version."
	echo "        - use 'git release checkout [true/false]' displays a list of release branches, allows for switching from release to release"
	echo "             + If you pass true as an argument, will automatically attempt to find the highest release candidate number"
	echo "                  If you're already on the highest candiate, nothing happens. If you aren't checkout proceeds and loads the release config"
	echo "                  'git release append' doesn't increase the rc number, however, so you may not get the latest config changes using this method"
	echo "                  This is the method employed when running 'git release pushfeature' to share the latest config between team members."

	echo "        - use 'git release devbranches' to list out branches that are contained in the development branch, that are not yet on the main branch"
	echo "              + if the development branch is not configured, you will be prompted to enter one"
	echo "        - use 'git release stagebranches' to list out branches that are contained in the staging branch, that are not yet on the main branch"
	echo "              + if the staging branch is not configured, you will be prompted to enter one"

	echo "        - use 'git release releasebranches' to list out branches that are contained in the release branch, that are not yet on the main branch"


	echo "        - use 'git release updatelocal' to update all of your local branches if they are behind origin. They are skipped if they are ahead of origin."
	echo "        - use 'git release newfeature' create a new branch from the main branch and push it to origin"
	echo "              + does case insensitive search to make sure the feature doesn't already exist."

	echo "        - use 'git release checkoutfeature' to find and create local branch from remote feature branch"
	echo "        - use 'git release pushfeature' to "
	echo "              + push the current branch to origin"
	echo "              + if this branch is not up to date on the development branch (as in 'git release devfeature')"
	echo "              + if this branch is part of the release, offer to roll a new release and push to origin"
	echo "                    * checks origin to see if you are on the latest release candidate, if not it performs a 'git release checkout'"
	echo "                    * roll - (same as 'git release roll') only offered when candidate is 0"
	echo "                    * next - (same as 'git release next')"
	echo "                    * append - (same as 'git release append') - might have issues if new features are added. If other developers"
	echo "                              attempt to 'append', 'git release checkout' won't read -r in the new features automatically and some"
	echo "                              features could be lost. If you want to do an append, you should manually run 'git release checkout'"
	echo "                              to pull down the latest release candidate and then confirm that your feature is configured the in"
	echo "                              the added features list."
	echo "              + if a new release is rolled, offer to merge it to staging and push it to origin (as in 'git release stage')"

	echo " "
	echo "  2. Manual :: 'git originalcreate [release-file]' stores the release versioning information in a simple file on the disk"
	echo "        - Release file sits on root of repo, and contains list of branches, one branch per line."
	echo " "
	echo " * * * * * * * * * * * * * * "
	echo " "
	echo " First time use? This will configure your initial release version, your development branch, and your staging/qa branche"
	echo " Run in this order:"

	echo " git release init"
	echo " git release devbranches"
	echo " git release stagebranches"
	echo " git release qabranches"
	echo " "
	echo " * * * * * * * * * * * * * * "
	echo " Poor man's continuous integration guide:"
	echo " Create a script you can call via http on your dev and staging environments in order to perform a plain 'git pull'"
	echo " Once you have those deployment urls, 'git release devfeature' and 'git release stage' can be configured to trigger them after pushing to origin."
	echo " git release setdevdeployurl"
	echo " git release setstagedeployurl"
	echo " git release setqadeployurl"

	echo " Works best if your dev site is always on the 'develop' branch, and your site for approved features is on the 'stage' branch."
	echo " "

	echo " * * * * * * * * * * * * * "
	echo " "

	echo " Workflow is:"
	echo " 'newfeature' - Create feature branches from origin/main."
	echo " 'add' feature branches to the release when they are ready for staging"
	echo " 'roll/next/append' a release candidate"
	echo " 'stage' a release candidate to your staging build"
	echo " Daily usage, when done committing a feature branch, use 'git release pushfeature' to enter interactive workflow pushing."
	echo " When feature branches are merged to the main branch, delete them"
	echo " When release branches are old, delete them"

}

COMMAND=$1

shift

if [ -z "$COMMAND" ]
	then
	echo " "
	echo " "
	echo ' use `git release help` for more command information. '
	echo " "
	echo " "
	echo " "
	echo ' use `git release status` to see what the current settings are.'
	status
fi

$COMMAND "$@"
